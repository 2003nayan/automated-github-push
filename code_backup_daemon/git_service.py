"""
Git operations service for Code Backup Daemon
"""
import subprocess
import logging
from pathlib import Path
from typing import Optional, List, Dict, Any
from datetime import datetime
import git
from git import Repo, InvalidGitRepositoryError

logger = logging.getLogger(__name__)

class GitService:
    """Handles all Git operations"""

    def __init__(self, config):
        self.config = config
        self.default_branch = config.get('git.default_branch', 'main')
        self.auto_commit_message = config.get('git.auto_commit_message', 'Auto-backup: {timestamp}')
        self.pull_before_push = config.get('git.pull_before_push', True)
        self.handle_conflicts = config.get('git.handle_conflicts', 'skip')

    def is_git_repo(self, path: Path) -> bool:
        """Check if directory is a git repository"""
        try:
            Repo(path)
            return True
        except InvalidGitRepositoryError:
            return False

    def init_repo(self, path: Path, username: str = None, email: str = None) -> bool:
        """Initialize a new git repository with optional user config"""
        try:
            repo = Repo.init(path)

            # Set repository-specific git config BEFORE making initial commit
            # This ensures the initial commit is attributed to the correct account
            if username and email:
                # Use config_writer and ensure it's released before commit
                config_writer = repo.config_writer()
                config_writer.set_value("user", "name", username)
                config_writer.set_value("user", "email", email)
                config_writer.release()  # Explicitly flush and close the config
                logger.info(f"Set git config for {path}: {username} <{email}>")

                # Verify config was set correctly
                actual_name = repo.config_reader().get_value("user", "name")
                actual_email = repo.config_reader().get_value("user", "email")
                logger.debug(f"Verified git config - name: {actual_name}, email: {actual_email}")

            # Set default branch
            if repo.head.is_valid():
                repo.git.branch('-M', self.default_branch)
            else:
                # Create initial commit
                self._create_initial_commit(repo, path)
                repo.git.branch('-M', self.default_branch)

            logger.info(f"Initialized git repository: {path}")
            return True

        except Exception as e:
            logger.error(f"Failed to initialize git repo at {path}: {e}")
            return False

    def _create_initial_commit(self, repo: Repo, path: Path):
        """Create initial commit with .gitignore"""
        # Create .gitignore if it doesn't exist
        gitignore_path = path / '.gitignore'
        if not gitignore_path.exists():
            self._create_gitignore(gitignore_path)

        # Stage all files
        repo.git.add('.')

        # Create initial commit using repo.git.commit() instead of repo.index.commit()
        # This ensures the commit uses the freshly set repository-level git config
        # rather than cached config from when the Repo object was instantiated
        repo.git.commit('-m', "Initial commit (auto-backup)")
        logger.info(f"Created initial commit for {path}")

    def _create_gitignore(self, gitignore_path: Path):
        """Create comprehensive .gitignore file"""
        ignore_patterns = self.config.get('project_detection.ignore_patterns', [])

        additional_patterns = [
            '# Auto-generated by code-backup-daemon',
            '',
            '# Dependencies',
            'node_modules/',
            'venv/',
            '.venv/',
            'env/',
            '__pycache__/',
            '*.pyc',
            '',
            '# IDE',
            '.vscode/',
            '.idea/',
            '*.swp',
            '*.swo',
            '',
            '# OS',
            '.DS_Store',
            'Thumbs.db',
            '',
            '# Logs',
            '*.log',
            'logs/',
            '',
            '# Environment',
            '.env',
            '.env.local',
            '.env.*.local',
            '',
            '# Build outputs',
            'dist/',
            'build/',
            'target/',
            '*.egg-info/',
        ]

        all_patterns = ignore_patterns + additional_patterns

        with open(gitignore_path, 'w') as f:
            f.write('\n'.join(all_patterns))

        logger.debug(f"Created .gitignore at {gitignore_path}")

    def set_repo_git_config(self, path: Path, username: str, email: str) -> bool:
        """Set git user config for specific repository

        This allows commits from different repositories to be attributed
        to the correct GitHub account when using multiple accounts.

        Args:
            path: Path to the git repository
            username: Git user.name (typically GitHub username)
            email: Git user.email

        Returns:
            bool: True if successful, False otherwise
        """
        try:
            repo = Repo(path)

            with repo.config_writer() as config_writer:
                config_writer.set_value("user", "name", username)
                config_writer.set_value("user", "email", email)

            logger.info(f"Set git config for {path}: {username} <{email}>")
            return True

        except Exception as e:
            logger.error(f"Failed to set git config for {path}: {e}")
            return False

    def has_remote(self, path: Path) -> bool:
        """Check if repository has remote configured"""
        try:
            repo = Repo(path)
            return len(repo.remotes) > 0
        except Exception:
            return False

    def get_remote_url(self, path: Path) -> Optional[str]:
        """Get the remote URL of the repository"""
        try:
            repo = Repo(path)
            if repo.remotes:
                return repo.remotes.origin.url
        except Exception as e:
            logger.debug(f"Could not get remote URL for {path}: {e}")
        return None

    def add_remote(self, path: Path, remote_url: str, name: str = 'origin') -> bool:
        """Add remote to repository"""
        try:
            repo = Repo(path)

            # Remove existing remote if it exists
            if name in [r.name for r in repo.remotes]:
                repo.delete_remote(name)

            # Add new remote
            repo.create_remote(name, remote_url)
            logger.info(f"Added remote '{name}' to {path}: {remote_url}")
            return True

        except Exception as e:
            logger.error(f"Failed to add remote to {path}: {e}")
            return False

    def has_uncommitted_changes(self, path: Path) -> bool:
        """Check if repository has uncommitted changes"""
        try:
            repo = Repo(path)
            return repo.is_dirty(untracked_files=True)
        except Exception as e:
            logger.error(f"Error checking for changes in {path}: {e}")
            return False

    def get_status(self, path: Path) -> Dict[str, Any]:
        """Get detailed status of repository"""
        try:
            repo = Repo(path)

            # Get untracked files
            untracked = repo.untracked_files

            # Get modified files
            modified = [item.a_path for item in repo.index.diff(None)]

            # Get staged files
            staged = [item.a_path for item in repo.index.diff("HEAD")]

            return {
                'is_dirty': repo.is_dirty(untracked_files=True),
                'untracked_files': untracked,
                'modified_files': modified,
                'staged_files': staged,
                'total_changes': len(untracked) + len(modified) + len(staged)
            }

        except Exception as e:
            logger.error(f"Error getting status for {path}: {e}")
            return {'is_dirty': False, 'total_changes': 0}

    def commit_changes(self, path: Path, message: Optional[str] = None) -> bool:
        """Commit all changes in repository"""
        try:
            repo = Repo(path)

            # Stage all changes
            repo.git.add('.')

            # Generate commit message
            if not message:
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                message = self.auto_commit_message.format(timestamp=timestamp)

            # Check if there are changes to commit
            if not repo.index.diff("HEAD") and not repo.untracked_files:
                logger.debug(f"No changes to commit in {path}")
                return True

            # Commit changes
            repo.index.commit(message)
            logger.info(f"Committed changes in {path}: {message}")
            return True

        except Exception as e:
            logger.error(f"Failed to commit changes in {path}: {e}")
            return False

    def pull_changes(self, path: Path) -> bool:
        """Pull changes from remote with rebase"""
        try:
            repo = Repo(path)

            if not repo.remotes:
                logger.debug(f"No remotes configured for {path}")
                return True

            # Check if we have internet connection and remote is reachable
            try:
                repo.remotes.origin.fetch()
            except Exception as e:
                logger.warning(f"Could not fetch from remote for {path}: {e}")
                return False

            # Check if remote branch exists
            try:
                remote_branch = f"origin/{self.default_branch}"
                if remote_branch not in [ref.name for ref in repo.refs]:
                    logger.debug(f"No remote branch {remote_branch} for {path}")
                    return True
            except Exception:
                return True

            # Pull with rebase
            result = repo.git.pull('--rebase')
            logger.info(f"Pulled changes for {path}")
            return True

        except Exception as e:
            if "conflict" in str(e).lower():
                logger.warning(f"Merge conflict in {path}: {e}")
                self._handle_conflict(path, e)
                return False
            else:
                logger.error(f"Failed to pull changes for {path}: {e}")
                return False

    def push_changes(self, path: Path) -> bool:
        """Push changes to remote"""
        try:
            repo = Repo(path)

            if not repo.remotes:
                logger.warning(f"No remotes configured for {path}")
                return False

            # Get current branch
            current_branch = repo.active_branch.name

            # Push to origin with upstream tracking
            origin = repo.remotes.origin
            push_info = origin.push(refspec=f'{current_branch}:{current_branch}', set_upstream=True)

            # Check push results - GitPython returns PushInfo objects
            if push_info:
                for info in push_info:
                    # Check for errors or rejections
                    if info.flags & info.ERROR:
                        logger.error(f"Push error for {path}: {info.summary}")
                        return False
                    if info.flags & info.REJECTED:
                        logger.error(f"Push rejected for {path}: {info.summary}")
                        return False
                    if info.flags & info.REMOTE_REJECTED:
                        logger.error(f"Push remote rejected for {path}: {info.summary}")
                        return False
                    if info.flags & info.REMOTE_FAILURE:
                        logger.error(f"Push remote failure for {path}: {info.summary}")
                        return False

            logger.info(f"Pushed changes for {path}")
            return True

        except Exception as e:
            logger.error(f"Failed to push changes for {path}: {e}")
            return False

    def sync_repository(self, path: Path) -> bool:
        """Complete sync: commit, pull, push"""
        logger.debug(f"Syncing repository: {path}")

        # Check for changes
        if not self.has_uncommitted_changes(path):
            logger.debug(f"No changes to sync in {path}")
            return True

        # Commit changes
        if not self.commit_changes(path):
            return False

        # Pull before push if configured
        if self.pull_before_push:
            if not self.pull_changes(path):
                if self.handle_conflicts == 'skip':
                    logger.warning(f"Skipping push due to conflicts in {path}")
                    return False
                # Other conflict handling strategies could be implemented here

        # Push changes
        return self.push_changes(path)

    def _handle_conflict(self, path: Path, error: Exception):
        """Handle merge conflicts based on configuration"""
        if self.handle_conflicts == 'skip':
            logger.warning(f"Skipping {path} due to conflicts")
        elif self.handle_conflicts == 'notify':
            # Could send notification here
            logger.error(f"Merge conflict in {path} - manual intervention required")
        elif self.handle_conflicts == 'force':
            # Force reset to local version (dangerous!)
            try:
                repo = Repo(path)
                repo.git.reset('--hard', 'HEAD')
                repo.git.clean('-fd')
                logger.warning(f"Force reset {path} to resolve conflicts")
            except Exception as e:
                logger.error(f"Failed to force reset {path}: {e}")

    def get_last_commit_info(self, path: Path) -> Optional[Dict[str, Any]]:
        """Get information about the last commit"""
        try:
            repo = Repo(path)
            last_commit = repo.head.commit

            return {
                'hash': last_commit.hexsha[:8],
                'message': last_commit.message.strip(),
                'author': str(last_commit.author),
                'date': datetime.fromtimestamp(last_commit.committed_date),
                'files_changed': len(last_commit.stats.files)
            }

        except Exception as e:
            logger.debug(f"Could not get last commit info for {path}: {e}")
            return None

    def cleanup_repo(self, path: Path):
        """Clean up repository (remove untracked files, prune, etc.)"""
        try:
            repo = Repo(path)

            # Clean untracked files
            repo.git.clean('-fd')

            # Garbage collect
            repo.git.gc('--auto')

            logger.debug(f"Cleaned up repository: {path}")

        except Exception as e:
            logger.debug(f"Could not clean up repository {path}: {e}")
